{"version":3,"file":"index.js","sources":["../lib/GabcSyllabified.ts","../lib/VerseText.ts","../lib/shiftGabc.ts","../lib/GabcPsalmTone.ts"],"sourcesContent":["export class GabcSyllabified {\n  /*-----  REGEX DEFS  -----*/\n  static readonly regexClef = /^[cf]b?[1-4]$/;\n  static readonly regexNonSyllabicGabc = /^([cf]b?[1-4]|[,;:`]+|[a-m]\\+|[zZ]0?)+$/;\n  static readonly regexFindParensWithLeadSpaces = /^(\\s*)\\((.*)\\)$/;\n  static readonly regexFindParens = /^\\((.*)\\)$/;\n\n  static merge(syllabifiedText: string, musicalNotation: string, useLargeInitial: boolean = true) {\n\n    const { text, notation } = GabcSyllabified.normalizeInputs(syllabifiedText, musicalNotation);\n\n    if (!notation) return text;\n\n    const { syllables, notationNodes } = GabcSyllabified.splitInputs(text, notation);\n\n    let sylNdx = 0\n    let isFirstSyl = true;\n    let result = notationNodes\n      .map((notation) => {\n        const { syllable, nextIndex, isFirstSyllable } = GabcSyllabified.mapSyllable(notation, syllables, sylNdx, isFirstSyl);\n        sylNdx = nextIndex;\n        isFirstSyl = isFirstSyllable;\n        return syllable;\n      })\n      .join('')\n      .trim()\n    ;\n\n    // add any additional syllables that come after the last notation data:\n    while (sylNdx < syllables.length) {\n      result +=\n        syllables[sylNdx++].replace(/^(\\s*)\"?\\(?(.*?)\\)?\"?$/, '$1$2') + '()';\n    }\n    return result;\n  }\n\n  /*-----  NORMALIZATION FUNCTIONS  -----*/\n  static normalizeInputs(text: string, notation: string): { text: string, notation: string } {\n    // normalize the text, getting rid of multiple consecutive whitespace,\n    // and handling lilypond's \\forceHyphen directive\n    // remove flex and mediant symbols if accents are marked with pipes:\n    if (/\\|/.test(text)) {\n      text = text.replace(/[†*]/g, \"\");\n    }\n\n    text = text.replace(/%[^\\n]*(\\n|$)/g, '$1')\n      .replace(/\\s*\\n\\s*/g, '\\n')\n      .replace(/(\\s)\\s+/g, '$1')\n      .replace(/\\\\forceHyphen\\s+(\\S+)\\s+--\\s+/g, '$1-')\n      .replace(/\\|([^|]+)\\|/g, '+$1+')\n      .replace(/([ -])\\+|\\+(\\W*(?:[-\\s]|$))/g, '$1$2')\n      .trim()\n    ;\n\n    notation = notation.replace(/%[^\\n]*(\\n|$)/g, '$1').trim();\n\n    return { text, notation }\n  }\n\n\n\n  static splitInputs(text: string, notation: string): { syllables: string[], notationNodes: string[] } {\n    const syllables = text\n      .split(/\\s+--\\s+|\\+|(\\s*\\(?\"[^\"]+\"\\)?-?)|(\\s*[^\\s-+]+-)(?=[^\\s-])|(?=\\s)/)\n      .filter(syl => syl && syl.trim())\n    ;\n    \n    const notationNodes = notation.split(/\\s+/);\n\n    return { syllables, notationNodes };\n  }\n\n  /*-----  STRING UTIL FUNCTIONS  -----*/\n  static stripParens(s: string) {\n    return s.replace(GabcSyllabified.regexFindParensWithLeadSpaces, '$1$2')\n        s.replace(GabcSyllabified.regexFindParens, '$1')\n    ;\n  }\n\n  /*-----  GETTER FUNCTIONS  -----*/\n  static getSyllable(syllables: string[], index: number) {\n    return (syllables[index] || ' ').replace(/^(\\s*)\"(.*)\"$/, '$1$2');\n  }\n\n  static getNonSyllable(syllables: string[], syllableNdx: number, notation: string): string {\n    let syllable = syllables[syllableNdx];\n\n    if (/^(\\s*!|[^a-záéíóúýàèìòùäëïöüÿæœǽœ́]+$|\\s*\\(.*\\)$|\\s*\"\\(.*\\)\"$)/i.test(syllable)\n        && !GabcSyllabified.regexClef.test(notation)) {\n\n      return syllable.replace(/^(\\s*)!/, '$1')\n          .replace(/^(\\s*)\"?\\((.*?)\\)\"?$/, '$1$2')\n      ;\n    }\n\n    return ' ';\n  }\n\n  /*-----  PROCESSOR FUNCTIONS  -----*/\n  static mapSyllable(\n    notation: string,\n    syllables: string[],\n    sylNdx: number,\n    isFirstSyllable: boolean\n  ): { syllable: string, nextIndex: number, isFirstSyllable: boolean } {\n    const noSyllable = GabcSyllabified.regexNonSyllabicGabc.test(notation) || /^\\(.*\\)$/.test(notation);\n    notation = GabcSyllabified.stripParens(notation);\n\n    let syllable = noSyllable ? GabcSyllabified.getNonSyllable(syllables, sylNdx, notation) : GabcSyllabified.getSyllable(syllables, sylNdx++);\n    if (!noSyllable) {\n      let nextSyllable = syllable;\n      syllable = GabcSyllabified.stripParens(syllable);\n\n      while (/^\\s*\\(.*\\)$/.test(nextSyllable)) {\n        if (/^\".*\"$/.test(syllable)) {\n          syllable = syllable.slice(1, -1);\n        }\n\n        nextSyllable = GabcSyllabified.getSyllable(syllables, sylNdx++);\n        syllable += '()' + GabcSyllabified.stripParens(nextSyllable);\n      }\n\n      if (isFirstSyllable) {\n        isFirstSyllable = false;\n\n        syllable = GabcSyllabified.capitalizeInitial(syllable, syllables[sylNdx]);\n      }\n    }\n\n    syllable = syllable + '(' + notation + ')';\n\n    return { syllable, nextIndex: sylNdx, isFirstSyllable }\n  }\n\n  static capitalizeInitial(syllable: string, nextSyllable: string): string {\n    if (/^\\s*[a-záéíóúýàèìòùäëïöüÿæœǽœ́]+/i.test(syllable)) {\n      // special capitalization rules for the large initial:\n      // the second letter should also be capitalized, and the third as well,\n      // if it is a three letter word\n      syllable = syllable.slice(0, 2).toUpperCase() + syllable.slice(2).toLowerCase();\n      if (syllable.length === 3 && /^\\s/.test(nextSyllable)) {\n        syllable = syllable.toUpperCase();\n      }\n    }\n\n    return syllable;\n  }\n}\n","import { GabcPsalmTone, GabcPsalmTones } from \"./GabcPsalmTone\";\nexport type Syllabifier = (word: string) => string[];\nexport type FormattedString = {\n  text: string;\n  style?: \"bold\" | \"italic\" | \"\" | null;\n};\nexport enum VerseSegmentType {\n  Flex = \"flex\",\n  Mediant = \"mediant\",\n  Termination = \"termination\"\n}\n\nexport const defaultSyllabifier: Syllabifier = text =>\n  text\n    .replace(/\\\\forceHyphen\\s+(\\S+)\\s+--\\s+/g, \"$1-\")\n    .replace(/\\s+--\\s+/g, \"+\")\n    .replace(/(\\|\\S+\\|)(\\S)/gi, \"$1+$2\")\n    .replace(/(\\S)(\\|\\S+\\|)/gi, \"$1+$2\")\n    .replace(/(\\S-)(\\S)/gi, \"$1+$2\")\n    .split(/\\+/g);\n\nexport class VerseText {\n  segments: VerseSegment[];\n\n  /**\n   *\n   * @param text the text to be split into segments\n   * @param syllabifier a function that takes a word string and returns an array of its syllables\n   */\n  constructor(text: string, syllabifier: Syllabifier = defaultSyllabifier) {\n    this.segments = VerseText.splitIntoSegments(text, syllabifier);\n  }\n\n  /**\n   * Returns a verse with GABC\n   * @param  {Object} psalmTone hash of GabcPsalmTones for flex, mediant, and termination\n   * @return {string}           GABC string\n   */\n  withGabc(\n    psalmTone: GabcPsalmTones,\n    {\n      startVersesOnNewLine = true,\n      stripFlexMediantSymbols = true,\n      addSequentialVerseNumbersStartingAt = 1\n    }: {\n      startVersesOnNewLine?: boolean;\n      stripFlexMediantSymbols?: boolean;\n      addSequentialVerseNumbersStartingAt?: number;\n    } = {}\n  ) {\n    let nextSequentialVerseNumber = addSequentialVerseNumbersStartingAt;\n    if (nextSequentialVerseNumber <= 0) nextSequentialVerseNumber = 0;\n    const getNextVerseNumberString = () =>\n      nextSequentialVerseNumber ? `${nextSequentialVerseNumber++}. ` : \"\";\n    return (\n      `(${psalmTone.clef}) ` +\n      this.segments\n        .map((seg, i, segments) => {\n          let useFlex = seg.segmentType === VerseSegmentType.Flex,\n            segmentName = useFlex ? VerseSegmentType.Mediant : seg.segmentType,\n            tone = psalmTone[segmentName];\n          let gabc = seg.withGabc(\n            tone as GabcPsalmTone,\n            i == 0 || i == this.segments.length - 1, // use intonation on first and last segment\n            useFlex,\n            stripFlexMediantSymbols\n          );\n          if (i === 0 || segments[i - 1].segmentType === VerseSegmentType.Termination)\n            gabc = getNextVerseNumberString() + gabc;\n          switch (seg.segmentType) {\n            case VerseSegmentType.Flex:\n              return gabc + \" (,)\";\n            case VerseSegmentType.Mediant:\n              return gabc + \" (:)\";\n            case VerseSegmentType.Termination:\n              return gabc + ` (::${startVersesOnNewLine ? \"Z\" : \"\"})`;\n          }\n        })\n        .join(\"\\n\\n\")\n    );\n  }\n\n  toString() {\n    return this.segments\n      .map((seg, i) => {\n        let prevSeg = this.segments[i - 1];\n        let indent = prevSeg && prevSeg.segmentType != VerseSegmentType.Termination;\n        return (indent ? \"\\t\" : \"\") + seg.toString();\n      })\n      .join(\"\\n\");\n  }\n\n  /**\n   * Split a text into segments based on the presence of †, * and \\n.\n   * @param  {string} text          the text to be split\n   * @param  {function} syllabifier a function that takes a string containing a single word, and returns an array of strings of the individual syllables.\n   * @return {VerseSegment[]}       the array of VerseSegment objects\n   */\n  static splitIntoSegments(text: string, syllabifier = defaultSyllabifier): VerseSegment[] {\n    let segmentSplit = text.split(/[ \\t]*([†*\\n/])(\\s*)/),\n      segments: VerseSegment[] = [];\n    for (let i = 0; i < segmentSplit.length; i += 3) {\n      let text = segmentSplit[i];\n      if (segmentSplit[i + 1]) {\n        text += \" \" + segmentSplit[i + 1];\n      }\n      segments.push(\n        new VerseSegment(\n          text,\n          syllabifier,\n          SegmentTypeDictionary[segmentSplit[i + 1] as keyof typeof SegmentTypeDictionary],\n          segmentSplit[i + 2]\n        )\n      );\n    }\n    return segments;\n  }\n}\n\nconst SegmentTypeDictionary = {\n  \"†\": VerseSegmentType.Flex,\n  \"*\": VerseSegmentType.Mediant,\n  \"\\n\": VerseSegmentType.Termination\n};\nclass VerseSegment {\n  words: VerseWord[];\n  syllables: VerseSyllable[];\n  segmentType: VerseSegmentType;\n  accentedSyllables: VerseSyllable[];\n  additionalWhitespace: string;\n\n  constructor(\n    text: string,\n    syllabifier = defaultSyllabifier,\n    type: VerseSegmentType = VerseSegmentType.Termination,\n    additionalWhitespace?: string\n  ) {\n    this.words = VerseSegment.splitIntoWords(text, syllabifier);\n    this.syllables = [].concat(...this.words.map(word => word.syllables));\n    this.segmentType = type;\n\n    // mark syllable indices:\n    this.syllables.forEach((syl, i) => (syl.indexInSegment = i));\n    this.syllables\n      .slice()\n      .reverse()\n      .forEach((syl, i) => (syl.indexFromSegmentEnd = i));\n\n    // mark the last two accents as 0 and 1:\n    this.accentedSyllables = this.syllables.filter(syl => syl.isAccented).reverse();\n\n    this.additionalWhitespace = additionalWhitespace || \"\";\n  }\n\n  /**\n   * get an array of objects containing a text and a style, based on so many accents and preparatory syllables\n   * @param  {number} accents     number of accents to mark at end\n   * @param  {number} preparatory number of preparatory syllables to mark before the first marked accent\n   * @param  {boolean} onlyMarkFirstPreparatory whether to mark only the first preparatory syllable\n   * @param  {string} syllableSeparator string used to separate syllables within the same word, defaults to \\xAD\n   * @return {Object[]}             Array of {text, style} objects\n   */\n  getFormattedStrings({\n    accents = 0,\n    preparatory = 0,\n    onlyMarkFirstPreparatory = false,\n    syllableSeparator = \"\\xAD\"\n  }: {\n    accents?: number;\n    preparatory?: number;\n    onlyMarkFirstPreparatory?: boolean;\n    syllableSeparator?: string;\n  } = {}): FormattedString[] {\n    let markedAccents = this.accentedSyllables.slice(this.accentedSyllables.length - accents);\n    let firstAccentIndex = markedAccents.length\n      ? markedAccents[0].indexInSegment || 0\n      : this.syllables.length;\n    let firstMarkedPreparatoryIndex = Math.max(0, firstAccentIndex - preparatory);\n    let result: FormattedString[] = [];\n    let workingString: FormattedString = {\n      text: this.syllables.slice(0, firstMarkedPreparatoryIndex).join(syllableSeparator)\n    };\n    let nextSyllableIndex = firstMarkedPreparatoryIndex;\n    let lastItalicIndex = onlyMarkFirstPreparatory\n      ? preparatory > 0\n        ? nextSyllableIndex + 1\n        : nextSyllableIndex\n      : firstAccentIndex;\n    let italics = this.syllables.slice(nextSyllableIndex, lastItalicIndex);\n    if (italics.length) {\n      let lastItalic = italics[italics.length - 1];\n      workingString.text += italics[0].getPreText();\n      result.push(workingString);\n      if (italics.length > 1) {\n        workingString = {\n          style: \"italic\",\n          text:\n            italics[0].withoutPreText() +\n            italics.slice(1, -1).join(\"\") +\n            lastItalic.withoutPostText()\n        };\n      } else {\n        workingString = {\n          style: \"italic\",\n          text: italics[0].text\n        };\n      }\n      result.push(workingString);\n      workingString = { text: lastItalic.getPostText() };\n      let nonItalic = this.syllables.slice(lastItalicIndex, firstAccentIndex);\n      workingString.text += nonItalic.join(\"\");\n    }\n    nextSyllableIndex = firstAccentIndex;\n    markedAccents.forEach((accent, i) => {\n      workingString.text += accent.getPreText();\n      result.push(workingString);\n\n      workingString = { style: \"bold\", text: accent.text };\n      result.push(workingString);\n\n      let nextAccent = markedAccents[i + 1];\n      workingString = { text: accent.getPostText() };\n      if (nextAccent) {\n        let nextSyllables = this.syllables.slice(\n          (accent.indexInSegment || 0) + 1,\n          nextAccent.indexInSegment\n        );\n        workingString.text += nextSyllables.join(\"\");\n        nextSyllableIndex = nextAccent.indexInSegment || 0;\n      } else {\n        ++nextSyllableIndex;\n      }\n    });\n    let nextSyllables = this.syllables.slice(nextSyllableIndex);\n    workingString.text += nextSyllables.join(syllableSeparator);\n    workingString.text = workingString.text.replace(/\\s+$/, \"\");\n    if (workingString.text) result.push(workingString);\n    return result;\n  }\n\n  /**\n   * returns GABC for this verse segment\n   * @param  {GabcPsalmTone} psalmTone definition for the psalm tone GABC\n   * @return {string}           GABC string\n   */\n  withGabc(\n    psalmTone: GabcPsalmTone,\n    useIntonation = true,\n    useFlex = false,\n    stripFlexMediantSymbols = true\n  ) {\n    let syllables = this.syllables.slice(),\n      { intonation, preparatory, accents, afterLastAccent, tenor, flex } = psalmTone.gabc,\n      result = \"\";\n    if (useFlex) {\n      afterLastAccent = [{ gabc: flex || \"\" }];\n      accents = [\n        [\n          { accent: true, gabc: tenor || \"\" },\n          { open: true, gabc: flex || \"\" }\n        ]\n      ];\n      preparatory = [];\n    }\n    let firstInterestingAccent = this.accentedSyllables[psalmTone.gabc.accents.length - 1],\n      indexOfFirstInterestingAccent = firstInterestingAccent\n        ? firstInterestingAccent.indexInSegment || 0\n        : syllables.length,\n      indexOfFirstPreparatory = indexOfFirstInterestingAccent - preparatory.length,\n      syllablesBeforePreparatory = syllables.slice(0, indexOfFirstPreparatory),\n      preparatorySyllables = syllables.slice(\n        indexOfFirstPreparatory,\n        indexOfFirstPreparatory + preparatory.length\n      ),\n      accentedSyllableAndAfter = syllables.slice(indexOfFirstPreparatory + preparatory.length);\n\n    // prepare GABC of intonation (if any)\n    if (!useIntonation) intonation = [];\n    if (intonation.length) {\n      for (let i = 0; i < intonation.length; ++i) {\n        let syl = syllablesBeforePreparatory.shift();\n        if (syl) result += syl.withGabc(intonation[i].gabc);\n      }\n    }\n    // handle all syllables on the reciting tone\n    syllablesBeforePreparatory.forEach(syl => (result += syl.withGabc(tenor || \"\")));\n    // handle preparatory syllables\n    preparatorySyllables.forEach((syl, i) => (result += syl.withGabc(preparatory[i].gabc)));\n\n    // handle the final accents:\n    let sylI = 0;\n    accents.forEach((accentTones, accentI) => {\n      let nextAccent = this.accentedSyllables[accents.length - 2 - accentI],\n        endSylI = nextAccent\n          ? (nextAccent.indexInSegment || 0) - (accentedSyllableAndAfter[0].indexInSegment || 0)\n          : accentedSyllableAndAfter.length - afterLastAccent.length;\n      // endSylI points to the next accent or to the first syllable applicable to afterLastAccent\n      accentTones.forEach((accentTone, i) => {\n        if (sylI >= endSylI) return;\n        let syl = accentedSyllableAndAfter[sylI];\n        if (accentTone.accent) {\n          // we're looking for an accented syllable\n          if (syl.isAccented || (sylI + 1 === endSylI && i === accentTones.length - 1)) {\n            // Use this syllable if it's accented or if we need to use something\n            result += syl.withGabc(accentTone.gabc);\n            ++sylI;\n          } else {\n            console.warn(\"Invalid state when applying psalm tone\");\n          }\n        } else if (accentTone.open) {\n          // take all syllables until the next accent:\n          let accentTonesRemaining = accentTones.length - 1 - i;\n          while (sylI < endSylI - accentTonesRemaining) {\n            result += syl.withGabc(accentTone.gabc);\n            syl = accentedSyllableAndAfter[++sylI];\n          }\n        }\n      });\n    });\n    let remainingSyllables = accentedSyllableAndAfter.slice(sylI);\n    if (remainingSyllables.length === afterLastAccent.length) {\n      remainingSyllables.forEach((syl, i) => (result += syl.withGabc(afterLastAccent[i].gabc)));\n    } else if (this.accentedSyllables.length) {\n      // only bother warning if there are actually marked accents in the text\n      console.warn(\n        \"Invalid state when applying psalm tone...incorrect number of syllables remaining\"\n      );\n    }\n    if (stripFlexMediantSymbols) result = result.replace(/\\s+[*†]/g, \"\");\n    return result;\n  }\n\n  toString() {\n    return this.words.join(\" \");\n  }\n\n  static splitIntoWords(text: string, syllabifier = defaultSyllabifier) {\n    let wordSplit = text\n      .trim()\n      .split(/([,;:.!?\"'’”»\\]\\)—–-]*)(?:$|\\s+|^)(?:\\[?(\\d+(?:[a-l]\\b)?)\\.?\\]?\\s*)?([\\(\\[«“‘'\"¿¡—–-]*)/);\n    // the text is now split into an array composed of text that didn't match\n    // the regex, followed by the first group of the regex, and the second\n    // group, and repeating.  We add two empty strings to the beginning and end\n    // of this array so that the array has a number of elements that is divisible by 4\n    // and is of the form [number,pre,word,post, number,pre,word,post,...]\n    wordSplit.unshift(\"\", \"\");\n    wordSplit.push(\"\");\n    let words = [],\n      lastWord,\n      preWord;\n    for (let i = 0; i + 2 < wordSplit.length; i += 4) {\n      if (!wordSplit[i + 2]) {\n        if (!(wordSplit[i + 1] || wordSplit[i + 3])) {\n          continue;\n        }\n        console.warn(\n          `no word found around ${i + 1} when splitting string ${JSON.stringify(\n            wordSplit\n          )} into words`\n        );\n      }\n      let verseWord = new VerseWord(\n        wordSplit[i + 2],\n        wordSplit[i + 1],\n        wordSplit[i + 3],\n        syllabifier,\n        wordSplit[i]\n      );\n      if (verseWord.isActualWord) {\n        if (preWord) {\n          verseWord.addPrePunctuation(preWord.syllables.join(\"\").trim());\n          preWord = null;\n        }\n        words.push(verseWord);\n        lastWord = verseWord;\n      } else if (lastWord) {\n        lastWord.addPunctuation(verseWord.syllables.join(\"\").trim());\n      } else {\n        preWord = verseWord;\n      }\n    }\n    return words;\n  }\n}\n\nclass VerseWord {\n  isActualWord: boolean;\n  prePunctuation: string;\n  punctuation: string;\n  syllables: VerseSyllable[];\n  verseNumber?: string;\n\n  constructor(\n    text: string,\n    pre: string,\n    post: string,\n    syllabifier = defaultSyllabifier,\n    verseNumber?: string\n  ) {\n    if (verseNumber) this.verseNumber = verseNumber;\n    this.isActualWord = /[a-z]/i.test(text);\n    this.prePunctuation = this.punctuation = \"\";\n    let syllabified = syllabifier(text);\n    this.syllables = syllabified.map(\n      (syl, i) => new VerseSyllable(syl, i === 0, i === syllabified.length - 1, pre, post, this)\n    );\n  }\n  /**\n   * adds punctuation that comes after the word, but is separated by a space\n   * @param {string} punctuation punctuation to add following the word\n   */\n  addPunctuation(punctuation: string) {\n    this.syllables[this.syllables.length - 1].postText += \"\\xA0\" + punctuation;\n  }\n  /**\n   * adds punctuation that comes before the word, but is separated by a space\n   * @param {string} prePunctuation punctuation to add before the word\n   */\n  addPrePunctuation(prePunctuation: string) {\n    this.syllables[0].preText = prePunctuation + \"\\xA0\" + this.syllables[0].preText;\n  }\n\n  toString() {\n    return this.syllables.join(\"+\");\n  }\n}\n\nclass VerseSyllable {\n  text: string;\n  word: VerseWord;\n  firstOfWord: boolean;\n  lastOfWord: boolean;\n  isAccented: boolean;\n  preText: string;\n  postText: string;\n\n  indexInSegment?: number;\n  indexFromSegmentEnd?: number;\n\n  constructor(\n    sylText: string,\n    firstOfWord: boolean,\n    lastOfWord: boolean,\n    pre: string | null | undefined,\n    post: string | null | undefined,\n    word: VerseWord\n  ) {\n    this.text = sylText;\n    this.word = word;\n    this.firstOfWord = firstOfWord;\n    this.lastOfWord = lastOfWord;\n    this.isAccented = /[áéíóúýǽ́]/i.test(sylText);\n    if (/^\\|[^|]+\\|$/.test(sylText)) {\n      this.text = sylText.slice(1, -1);\n      this.isAccented = true;\n    }\n    this.preText = (firstOfWord && pre) || \"\";\n    this.postText = (lastOfWord && post) || \"\";\n  }\n\n  toString() {\n    return this.preText + this.text + this.postText + (this.lastOfWord ? \" \" : \"\");\n  }\n  withoutPreText() {\n    return this.text + this.postText + (this.lastOfWord ? \" \" : \"\");\n  }\n  withoutPostText() {\n    return this.preText + this.text;\n  }\n  getPreText() {\n    return this.preText;\n  }\n  getPostText() {\n    return this.postText + (this.lastOfWord ? \" \" : \"\");\n  }\n\n  withGabc(gabc: string) {\n    return this.preText + this.text + this.postText + `(${gabc})` + (this.lastOfWord ? \"\\n\" : \"\");\n  }\n}\n","/**\n * shift all notes in GABC by shift (upward if positive, downward if negative)\n * @param gabc string of GABC (without parentheses)\n * @param shift amount to shift\n */\nexport function shiftGabc(gabc: string, shift: number) {\n  return gabc.replace(/([cf]b?[1-4])|([a-m])/gi, (match, clef, c) => {\n    if (clef) return clef;\n    const newC = String.fromCharCode(c.charCodeAt(0) + shift);\n    if (!/[a-m]/i.test(newC)) throw \"cannot be shifted that much\";\n    return newC;\n  });\n}\n","import { VerseSegmentType } from \"./VerseText\";\nimport { shiftGabc } from \"./shiftGabc\";\n\nexport type GabcPsalmTones = {\n  [VerseSegmentType.Flex]?: GabcPsalmTone;\n  [VerseSegmentType.Mediant]: GabcPsalmTone;\n  [VerseSegmentType.Termination]: GabcPsalmTone;\n  originalGabc: string;\n  clef: string;\n};\nexport type GabcPsalmToneOptions = {\n  treatAsOneAccentWithXPreparatory?: boolean;\n};\n\ntype GabcSingleTone = {\n  gabc: string;\n  accent?: boolean;\n  open?: boolean;\n};\ntype GabcInfo = {\n  tenor?: string;\n  flex?: string;\n  intonation: GabcSingleTone[];\n  preparatory: GabcSingleTone[];\n  afterLastAccent: GabcSingleTone[];\n  accents: GabcSingleTone[][];\n};\ntype SyllableCounts = {\n  intonation: number;\n  accents: number;\n  preparatory: number;\n  afterLastAccent: number;\n};\n\nexport class GabcPsalmTone {\n  /**\n   * Takes gabc like `(jr//////////k//j)(:)(jr////////h///i//g)(::)` or\n   *                 `jr k j : jr h i g ::\n   * and\n   * @param  {string} gabc GABC code for psalm tone\n   * @param  {string} clef GABC clef code\n   * @param  {object} options special options as a hash of booleans:\n   * treatAsOneAccentWithXPreparatory:\n   * @return {{mediant: GabcPsalmTone, termination: GabcPsalmTone}}      object hash with mediant and termination\n   */\n  static getFromGabc(\n    gabc: string,\n    options: GabcPsalmToneOptions = {},\n    clef?: string\n  ): GabcPsalmTones {\n    gabc = gabc.replace(/[/()]+/g, \" \");\n    let originalGabc = gabc;\n    let clefMatch = /^[^a-m]*((?:cb?|f)[1-4])/.exec(gabc);\n    if (clefMatch) {\n      const detectedClef = clefMatch[1],\n        desiredClef = clef;\n      if (clef && clef.slice(0, -1) === detectedClef.slice(0, -1)) {\n        const detectedClefPosition = parseInt(detectedClef.slice(-1)),\n          desiredClefPosition = parseInt(clef.slice(-1)),\n          shift = 2 * (desiredClefPosition - detectedClefPosition);\n        // shift the psalm tone\n        try {\n          gabc = shiftGabc(gabc, shift);\n        } catch(exception) {\n          clef = detectedClef;\n        }\n      } else {\n        clef = detectedClef;\n      }\n      gabc = gabc.slice(clefMatch.index + clefMatch[0].length);\n    } else if (!clef) {\n      clef = \"c4\";\n    }\n    originalGabc = clef + \" \" + gabc.trim();\n    let gabcSegments = gabc.split(\" : \");\n    if (gabcSegments.length != 2) {\n      console.warn(\"GabcPsalmTone.getFromGabc called on invalid GABC:\", gabc);\n    }\n    let gabcPsalmTones = gabcSegments.map(gabc => {\n      gabc = gabc.replace(/::\\s*$/, \"\").trim();\n      if (options.treatAsOneAccentWithXPreparatory) {\n        let match = gabc.match(/\\s(([^\\sr',;:])+)$/);\n        if (match) {\n          // jr h i g => jr h i 'g gr g\n          gabc =\n            gabc.slice(0, -match[0].length) +\n            \" '\" +\n            match[1] +\n            \" \" +\n            match[2].toLowerCase() +\n            \"r \" +\n            match[2].toLowerCase();\n        }\n      }\n      return new GabcPsalmTone(gabc, \"\", true, clef);\n    });\n    return {\n      [VerseSegmentType.Mediant]: gabcPsalmTones[0],\n      [VerseSegmentType.Termination]: gabcPsalmTones[1],\n      originalGabc,\n      clef\n    };\n  }\n\n  tones: GabcSingleTone[];\n  clef: string;\n  gabc: GabcInfo;\n  syllableCounts: SyllableCounts;\n\n  constructor(gabc: string, prefix = \"\", flexEqualsTenor = false, clef = \"c4\") {\n    let tones: GabcSingleTone[] = (this.tones = []);\n    if (prefix) gabc = prefix + gabc;\n    let match;\n    let index = 0;\n    let regexToneGabc = /(')?(([^\\sr]+)(r)?)(?=$|\\s)/gi;\n    while ((match = regexToneGabc.exec(gabc))) {\n      tones.push({\n        accent: match[1] == \"'\",\n        gabc: match[3],\n        open: match[4] == \"r\"\n      });\n    }\n    var intonation: GabcSingleTone[] = [];\n    var accentedTones: GabcSingleTone[][] = [];\n    var currentAccentTone;\n    var preparatory: GabcSingleTone[] = [];\n    var afterLastAccent: GabcSingleTone[] = [];\n    var state = 3;\n    var lastOpen = undefined;\n    var toneTenor;\n    var toneFlex;\n    for (var i = tones.length - 1; i >= 0; --i) {\n      var ton = tones[i];\n      if (ton.accent) {\n        currentAccentTone = [ton];\n        accentedTones.unshift(currentAccentTone);\n        state = 1;\n        if (lastOpen) {\n          currentAccentTone.push(lastOpen);\n          lastOpen = undefined;\n        } else if (tones[i - 1].open) {\n          currentAccentTone.unshift(tones[i - 1]);\n          --i;\n        }\n        preparatory = [];\n      } else if (ton.open) {\n        toneTenor = ton.gabc[0];\n        if (state == 3) {\n          // initial state: no accents have been found yet\n          if (accentedTones.length == 0 && (i == 0 || !tones[i - 1].accent)) {\n            // if we got all the way to the beginning or the intonation, what we\n            // had considered to be after the last accent should really be\n            // interpreted as preparatory syllables\n            preparatory = afterLastAccent;\n            afterLastAccent = [];\n          }\n          state = 1;\n        }\n        lastOpen = ton;\n      } else if (state == 3) {\n        // initial state: no accents or puncta cava have been found yet\n        afterLastAccent.unshift(ton);\n      } else if (state == 1) {\n        // state 1 means there has already been found an accent or punctum cavum\n        if (!lastOpen) {\n          // the following tone to this one is an accent, so this must be a\n          // preparatory syllable:\n          preparatory.unshift(ton);\n        } else {\n          // the following tone to this one is a cavum, so this is probably an\n          // intonation syllable, but we won't consider it as such if has the\n          // same GABC code as the the tenor (or if we have already gotten the\n          // last syllable of the intonation)\n          if (intonation.length > 0 || ton.gabc != lastOpen.gabc) intonation.unshift(ton);\n          continue;\n        }\n        lastOpen = undefined;\n      }\n    }\n    if (toneTenor) {\n      if (flexEqualsTenor) {\n        toneFlex = toneTenor;\n      } else {\n        // calculate flex tone based on it being a full tone below the tenor,\n        // unless this would only be a semitone in the psalm tone's clef\n        let clefI = clef[0] == \"f\" ? 6 : 1;\n        clefI += +parseInt(clef.slice(-1)) * 2;\n        let toneNumber = (parseInt(toneTenor, 36) - 10 + 16 - clefI) % 8;\n        let code = toneTenor.charCodeAt(0);\n        code -= toneNumber == 0 || toneNumber == 3 ? 2 : 1;\n        toneFlex = String.fromCharCode(code);\n      }\n    }\n    this.clef = clef;\n    this.gabc = {\n      tenor: toneTenor,\n      flex: toneFlex,\n      intonation,\n      preparatory,\n      afterLastAccent,\n      accents: accentedTones\n    };\n    this.syllableCounts = {\n      intonation: intonation.length,\n      accents: accentedTones.length,\n      preparatory: preparatory.length,\n      afterLastAccent: afterLastAccent.length\n    };\n  }\n}\n"],"names":["VerseSegmentType"],"mappings":";;;IAAA;KAmJC;IA5IQ,qBAAK,GAAZ,UAAa,eAAuB,EAAE,eAAuB,EAAE,eAA+B;QAEtF,IAAA,KAAqB,eAAe,CAAC,eAAe,CAAC,eAAe,EAAE,eAAe,CAAC,EAApF,IAAI,UAAA,EAAE,QAAQ,cAAsE,CAAC;QAE7F,IAAI,CAAC,QAAQ;YAAE,OAAO,IAAI,CAAC;QAErB,IAAA,KAA+B,eAAe,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,EAAxE,SAAS,eAAA,EAAE,aAAa,mBAAgD,CAAC;QAEjF,IAAI,MAAM,GAAG,CAAC,CAAA;QACd,IAAI,UAAU,GAAG,IAAI,CAAC;QACtB,IAAI,MAAM,GAAG,aAAa;aACvB,GAAG,CAAC,UAAC,QAAQ;YACN,IAAA,KAA2C,eAAe,CAAC,WAAW,CAAC,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,UAAU,CAAC,EAA7G,QAAQ,cAAA,EAAE,SAAS,eAAA,EAAE,eAAe,qBAAyE,CAAC;YACtH,MAAM,GAAG,SAAS,CAAC;YACnB,UAAU,GAAG,eAAe,CAAC;YAC7B,OAAO,QAAQ,CAAC;SACjB,CAAC;aACD,IAAI,CAAC,EAAE,CAAC;aACR,IAAI,EAAE,CACR;;QAGD,OAAO,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE;YAChC,MAAM;gBACJ,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC,OAAO,CAAC,wBAAwB,EAAE,MAAM,CAAC,GAAG,IAAI,CAAC;SACxE;QACD,OAAO,MAAM,CAAC;KACf;;IAGM,+BAAe,GAAtB,UAAuB,IAAY,EAAE,QAAgB;;;;QAInD,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACnB,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;SAClC;QAED,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC;aACxC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC;aAC1B,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;aACzB,OAAO,CAAC,gCAAgC,EAAE,KAAK,CAAC;aAChD,OAAO,CAAC,cAAc,EAAE,MAAM,CAAC;aAC/B,OAAO,CAAC,8BAA8B,EAAE,MAAM,CAAC;aAC/C,IAAI,EAAE,CACR;QAED,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;QAE3D,OAAO,EAAE,IAAI,MAAA,EAAE,QAAQ,UAAA,EAAE,CAAA;KAC1B;IAIM,2BAAW,GAAlB,UAAmB,IAAY,EAAE,QAAgB;QAC/C,IAAM,SAAS,GAAG,IAAI;aACnB,KAAK,CAAC,kEAAkE,CAAC;aACzE,MAAM,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,IAAI,GAAG,CAAC,IAAI,EAAE,GAAA,CAAC,CAClC;QAED,IAAM,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAE5C,OAAO,EAAE,SAAS,WAAA,EAAE,aAAa,eAAA,EAAE,CAAC;KACrC;;IAGM,2BAAW,GAAlB,UAAmB,CAAS;QAC1B,OAAO,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,6BAA6B,EAAE,MAAM,CAAC,CAAA;KAGxE;;IAGM,2BAAW,GAAlB,UAAmB,SAAmB,EAAE,KAAa;QACnD,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,GAAG,EAAE,OAAO,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;KACnE;IAEM,8BAAc,GAArB,UAAsB,SAAmB,EAAE,WAAmB,EAAE,QAAgB;QAC9E,IAAI,QAAQ,GAAG,SAAS,CAAC,WAAW,CAAC,CAAC;QAEtC,IAAI,iEAAiE,CAAC,IAAI,CAAC,QAAQ,CAAC;eAC7E,CAAC,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YAEhD,OAAO,QAAQ,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC;iBACnC,OAAO,CAAC,sBAAsB,EAAE,MAAM,CAAC,CAC3C;SACF;QAED,OAAO,GAAG,CAAC;KACZ;;IAGM,2BAAW,GAAlB,UACE,QAAgB,EAChB,SAAmB,EACnB,MAAc,EACd,eAAwB;QAExB,IAAM,UAAU,GAAG,eAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpG,QAAQ,GAAG,eAAe,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QAEjD,IAAI,QAAQ,GAAG,UAAU,GAAG,eAAe,CAAC,cAAc,CAAC,SAAS,EAAE,MAAM,EAAE,QAAQ,CAAC,GAAG,eAAe,CAAC,WAAW,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;QAC3I,IAAI,CAAC,UAAU,EAAE;YACf,IAAI,YAAY,GAAG,QAAQ,CAAC;YAC5B,QAAQ,GAAG,eAAe,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;YAEjD,OAAO,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;gBACvC,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;oBAC3B,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;iBAClC;gBAED,YAAY,GAAG,eAAe,CAAC,WAAW,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;gBAChE,QAAQ,IAAI,IAAI,GAAG,eAAe,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;aAC9D;YAED,IAAI,eAAe,EAAE;gBACnB,eAAe,GAAG,KAAK,CAAC;gBAExB,QAAQ,GAAG,eAAe,CAAC,iBAAiB,CAAC,QAAQ,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;aAC3E;SACF;QAED,QAAQ,GAAG,QAAQ,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,CAAC;QAE3C,OAAO,EAAE,QAAQ,UAAA,EAAE,SAAS,EAAE,MAAM,EAAE,eAAe,iBAAA,EAAE,CAAA;KACxD;IAEM,iCAAiB,GAAxB,UAAyB,QAAgB,EAAE,YAAoB;QAC7D,IAAI,mCAAmC,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;;;;YAItD,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;YAChF,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;gBACrD,QAAQ,GAAG,QAAQ,CAAC,WAAW,EAAE,CAAC;aACnC;SACF;QAED,OAAO,QAAQ,CAAC;KACjB;;IAhJe,yBAAS,GAAG,eAAe,CAAC;IAC5B,oCAAoB,GAAG,yCAAyC,CAAC;IACjE,6CAA6B,GAAG,iBAAiB,CAAC;IAClD,+BAAe,GAAG,YAAY,CAAC;IA8IjD,sBAAC;CAnJD;;ACMA,WAAY,gBAAgB;IAC1B,iCAAa,CAAA;IACb,uCAAmB,CAAA;IACnB,+CAA2B,CAAA;AAC7B,CAAC,EAJWA,wBAAgB,KAAhBA,wBAAgB,QAI3B;IAEY,kBAAkB,GAAgB,UAAA,IAAI;IACjD,OAAA,IAAI;SACD,OAAO,CAAC,gCAAgC,EAAE,KAAK,CAAC;SAChD,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC;SACzB,OAAO,CAAC,iBAAiB,EAAE,OAAO,CAAC;SACnC,OAAO,CAAC,iBAAiB,EAAE,OAAO,CAAC;SACnC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC;SAC/B,KAAK,CAAC,KAAK,CAAC;AANf,EAMgB;;;;;;;IAUhB,mBAAY,IAAY,EAAE,WAA6C;QAA7C,4BAAA,EAAA,gCAA6C;QACrE,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,iBAAiB,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;KAChE;;;;;;IAOD,4BAAQ,GAAR,UACE,SAAyB,EACzB,EAQM;QAVR,iBA0CC;YAxCC,qBAQI,EAAE,KAAA,EAPJ,4BAA2B,EAA3B,oBAAoB,mBAAG,IAAI,KAAA,EAC3B,+BAA8B,EAA9B,uBAAuB,mBAAG,IAAI,KAAA,EAC9B,2CAAuC,EAAvC,mCAAmC,mBAAG,CAAC,KAAA;QAOzC,IAAI,yBAAyB,GAAG,mCAAmC,CAAC;QACpE,IAAI,yBAAyB,IAAI,CAAC;YAAE,yBAAyB,GAAG,CAAC,CAAC;QAClE,IAAM,wBAAwB,GAAG;YAC/B,OAAA,yBAAyB,GAAM,yBAAyB,EAAE,OAAI,GAAG,EAAE;SAAA,CAAC;QACtE,QACE,MAAI,SAAS,CAAC,IAAI,OAAI;YACtB,IAAI,CAAC,QAAQ;iBACV,GAAG,CAAC,UAAC,GAAG,EAAE,CAAC,EAAE,QAAQ;gBACpB,IAAI,OAAO,GAAG,GAAG,CAAC,WAAW,KAAKA,wBAAgB,CAAC,IAAI,EACrD,WAAW,GAAG,OAAO,GAAGA,wBAAgB,CAAC,OAAO,GAAG,GAAG,CAAC,WAAW,EAClE,IAAI,GAAG,SAAS,CAAC,WAAW,CAAC,CAAC;gBAChC,IAAI,IAAI,GAAG,GAAG,CAAC,QAAQ,CACrB,IAAqB,EACrB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC;gBACvC,OAAO,EACP,uBAAuB,CACxB,CAAC;gBACF,IAAI,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,KAAKA,wBAAgB,CAAC,WAAW;oBACzE,IAAI,GAAG,wBAAwB,EAAE,GAAG,IAAI,CAAC;gBAC3C,QAAQ,GAAG,CAAC,WAAW;oBACrB,KAAKA,wBAAgB,CAAC,IAAI;wBACxB,OAAO,IAAI,GAAG,MAAM,CAAC;oBACvB,KAAKA,wBAAgB,CAAC,OAAO;wBAC3B,OAAO,IAAI,GAAG,MAAM,CAAC;oBACvB,KAAKA,wBAAgB,CAAC,WAAW;wBAC/B,OAAO,IAAI,IAAG,UAAO,oBAAoB,GAAG,GAAG,GAAG,EAAE,OAAG,CAAA,CAAC;iBAC3D;aACF,CAAC;iBACD,IAAI,CAAC,MAAM,CAAC,EACf;KACH;IAED,4BAAQ,GAAR;QAAA,iBAQC;QAPC,OAAO,IAAI,CAAC,QAAQ;aACjB,GAAG,CAAC,UAAC,GAAG,EAAE,CAAC;YACV,IAAI,OAAO,GAAG,KAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACnC,IAAI,MAAM,GAAG,OAAO,IAAI,OAAO,CAAC,WAAW,IAAIA,wBAAgB,CAAC,WAAW,CAAC;YAC5E,OAAO,CAAC,MAAM,GAAG,IAAI,GAAG,EAAE,IAAI,GAAG,CAAC,QAAQ,EAAE,CAAC;SAC9C,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,CAAC;KACf;;;;;;;IAQM,2BAAiB,GAAxB,UAAyB,IAAY,EAAE,WAAgC;QAAhC,4BAAA,EAAA,gCAAgC;QACrE,IAAI,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC,EACnD,QAAQ,GAAmB,EAAE,CAAC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YAC/C,IAAI,MAAI,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gBACvB,MAAI,IAAI,GAAG,GAAG,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;aACnC;YACD,QAAQ,CAAC,IAAI,CACX,IAAI,YAAY,CACd,MAAI,EACJ,WAAW,EACX,qBAAqB,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,CAAuC,CAAC,EAChF,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,CACpB,CACF,CAAC;SACH;QACD,OAAO,QAAQ,CAAC;KACjB;IACH,gBAAC;AAAD,CAAC,IAAA;AAED,IAAM,qBAAqB,GAAG;IAC5B,GAAG,EAAEA,wBAAgB,CAAC,IAAI;IAC1B,GAAG,EAAEA,wBAAgB,CAAC,OAAO;IAC7B,IAAI,EAAEA,wBAAgB,CAAC,WAAW;CACnC,CAAC;AACF;IAOE,sBACE,IAAY,EACZ,WAAgC,EAChC,IAAqD,EACrD,oBAA6B;QAF7B,4BAAA,EAAA,gCAAgC;QAChC,qBAAA,EAAA,OAAyBA,wBAAgB,CAAC,WAAW;QAGrD,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC,cAAc,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;QAC5D,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC,MAAM,OAAT,EAAE,EAAW,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,SAAS,GAAA,CAAC,CAAC,CAAC;QACtE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;;QAGxB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAC,GAAG,EAAE,CAAC,IAAK,QAAC,GAAG,CAAC,cAAc,GAAG,CAAC,IAAC,CAAC,CAAC;QAC7D,IAAI,CAAC,SAAS;aACX,KAAK,EAAE;aACP,OAAO,EAAE;aACT,OAAO,CAAC,UAAC,GAAG,EAAE,CAAC,IAAK,QAAC,GAAG,CAAC,mBAAmB,GAAG,CAAC,IAAC,CAAC,CAAC;;QAGtD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,UAAU,GAAA,CAAC,CAAC,OAAO,EAAE,CAAC;QAEhF,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,IAAI,EAAE,CAAC;KACxD;;;;;;;;;IAUD,0CAAmB,GAAnB,UAAoB,EAUd;QAVN,iBA4EC;YA5EmB,qBAUhB,EAAE,KAAA,EATJ,eAAW,EAAX,OAAO,mBAAG,CAAC,KAAA,EACX,mBAAe,EAAf,WAAW,mBAAG,CAAC,KAAA,EACf,gCAAgC,EAAhC,wBAAwB,mBAAG,KAAK,KAAA,EAChC,yBAA0B,EAA1B,iBAAiB,mBAAG,MAAM,KAAA;QAO1B,IAAI,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,GAAG,OAAO,CAAC,CAAC;QAC1F,IAAI,gBAAgB,GAAG,aAAa,CAAC,MAAM;cACvC,aAAa,CAAC,CAAC,CAAC,CAAC,cAAc,IAAI,CAAC;cACpC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;QAC1B,IAAI,2BAA2B,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,gBAAgB,GAAG,WAAW,CAAC,CAAC;QAC9E,IAAI,MAAM,GAAsB,EAAE,CAAC;QACnC,IAAI,aAAa,GAAoB;YACnC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,2BAA2B,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC;SACnF,CAAC;QACF,IAAI,iBAAiB,GAAG,2BAA2B,CAAC;QACpD,IAAI,eAAe,GAAG,wBAAwB;cAC1C,WAAW,GAAG,CAAC;kBACb,iBAAiB,GAAG,CAAC;kBACrB,iBAAiB;cACnB,gBAAgB,CAAC;QACrB,IAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,iBAAiB,EAAE,eAAe,CAAC,CAAC;QACvE,IAAI,OAAO,CAAC,MAAM,EAAE;YAClB,IAAI,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAC7C,aAAa,CAAC,IAAI,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC3B,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;gBACtB,aAAa,GAAG;oBACd,KAAK,EAAE,QAAQ;oBACf,IAAI,EACF,OAAO,CAAC,CAAC,CAAC,CAAC,cAAc,EAAE;wBAC3B,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;wBAC7B,UAAU,CAAC,eAAe,EAAE;iBAC/B,CAAC;aACH;iBAAM;gBACL,aAAa,GAAG;oBACd,KAAK,EAAE,QAAQ;oBACf,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI;iBACtB,CAAC;aACH;YACD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC3B,aAAa,GAAG,EAAE,IAAI,EAAE,UAAU,CAAC,WAAW,EAAE,EAAE,CAAC;YACnD,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,eAAe,EAAE,gBAAgB,CAAC,CAAC;YACxE,aAAa,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAC1C;QACD,iBAAiB,GAAG,gBAAgB,CAAC;QACrC,aAAa,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,CAAC;YAC9B,aAAa,CAAC,IAAI,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YAC1C,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAE3B,aAAa,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,CAAC;YACrD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAE3B,IAAI,UAAU,GAAG,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACtC,aAAa,GAAG,EAAE,IAAI,EAAE,MAAM,CAAC,WAAW,EAAE,EAAE,CAAC;YAC/C,IAAI,UAAU,EAAE;gBACd,IAAI,eAAa,GAAG,KAAI,CAAC,SAAS,CAAC,KAAK,CACtC,CAAC,MAAM,CAAC,cAAc,IAAI,CAAC,IAAI,CAAC,EAChC,UAAU,CAAC,cAAc,CAC1B,CAAC;gBACF,aAAa,CAAC,IAAI,IAAI,eAAa,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBAC7C,iBAAiB,GAAG,UAAU,CAAC,cAAc,IAAI,CAAC,CAAC;aACpD;iBAAM;gBACL,EAAE,iBAAiB,CAAC;aACrB;SACF,CAAC,CAAC;QACH,IAAI,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAC5D,aAAa,CAAC,IAAI,IAAI,aAAa,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC5D,aAAa,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC5D,IAAI,aAAa,CAAC,IAAI;YAAE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACnD,OAAO,MAAM,CAAC;KACf;;;;;;IAOD,+BAAQ,GAAR,UACE,SAAwB,EACxB,aAAoB,EACpB,OAAe,EACf,uBAA8B;QAJhC,iBAqFC;QAnFC,8BAAA,EAAA,oBAAoB;QACpB,wBAAA,EAAA,eAAe;QACf,wCAAA,EAAA,8BAA8B;QAE9B,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,EACpC,KAAqE,SAAS,CAAC,IAAI,EAAjF,UAAU,gBAAA,EAAE,WAAW,iBAAA,EAAE,OAAO,aAAA,EAAE,eAAe,qBAAA,EAAE,KAAK,WAAA,EAAE,IAAI,UAAA,EAChE,MAAM,GAAG,EAAE,CAAC;QACd,IAAI,OAAO,EAAE;YACX,eAAe,GAAG,CAAC,EAAE,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,CAAC,CAAC;YACzC,OAAO,GAAG;gBACR;oBACE,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,IAAI,EAAE,EAAE;oBACnC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE;iBACjC;aACF,CAAC;YACF,WAAW,GAAG,EAAE,CAAC;SAClB;QACD,IAAI,sBAAsB,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,EACpF,6BAA6B,GAAG,sBAAsB;cAClD,sBAAsB,CAAC,cAAc,IAAI,CAAC;cAC1C,SAAS,CAAC,MAAM,EACpB,uBAAuB,GAAG,6BAA6B,GAAG,WAAW,CAAC,MAAM,EAC5E,0BAA0B,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,uBAAuB,CAAC,EACxE,oBAAoB,GAAG,SAAS,CAAC,KAAK,CACpC,uBAAuB,EACvB,uBAAuB,GAAG,WAAW,CAAC,MAAM,CAC7C,EACD,wBAAwB,GAAG,SAAS,CAAC,KAAK,CAAC,uBAAuB,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;;QAG3F,IAAI,CAAC,aAAa;YAAE,UAAU,GAAG,EAAE,CAAC;QACpC,IAAI,UAAU,CAAC,MAAM,EAAE;YACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBAC1C,IAAI,GAAG,GAAG,0BAA0B,CAAC,KAAK,EAAE,CAAC;gBAC7C,IAAI,GAAG;oBAAE,MAAM,IAAI,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;aACrD;SACF;;QAED,0BAA0B,CAAC,OAAO,CAAC,UAAA,GAAG,IAAI,QAAC,MAAM,IAAI,GAAG,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE,CAAC,IAAC,CAAC,CAAC;;QAEjF,oBAAoB,CAAC,OAAO,CAAC,UAAC,GAAG,EAAE,CAAC,IAAK,QAAC,MAAM,IAAI,GAAG,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAC,CAAC,CAAC;;QAGxF,IAAI,IAAI,GAAG,CAAC,CAAC;QACb,OAAO,CAAC,OAAO,CAAC,UAAC,WAAW,EAAE,OAAO;YACnC,IAAI,UAAU,GAAG,KAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,OAAO,CAAC,EACnE,OAAO,GAAG,UAAU;kBAChB,CAAC,UAAU,CAAC,cAAc,IAAI,CAAC,KAAK,wBAAwB,CAAC,CAAC,CAAC,CAAC,cAAc,IAAI,CAAC,CAAC;kBACpF,wBAAwB,CAAC,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;;YAE/D,WAAW,CAAC,OAAO,CAAC,UAAC,UAAU,EAAE,CAAC;gBAChC,IAAI,IAAI,IAAI,OAAO;oBAAE,OAAO;gBAC5B,IAAI,GAAG,GAAG,wBAAwB,CAAC,IAAI,CAAC,CAAC;gBACzC,IAAI,UAAU,CAAC,MAAM,EAAE;;oBAErB,IAAI,GAAG,CAAC,UAAU,KAAK,IAAI,GAAG,CAAC,KAAK,OAAO,IAAI,CAAC,KAAK,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;;wBAE5E,MAAM,IAAI,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;wBACxC,EAAE,IAAI,CAAC;qBACR;yBAAM;wBACL,OAAO,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;qBACxD;iBACF;qBAAM,IAAI,UAAU,CAAC,IAAI,EAAE;;oBAE1B,IAAI,oBAAoB,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;oBACtD,OAAO,IAAI,GAAG,OAAO,GAAG,oBAAoB,EAAE;wBAC5C,MAAM,IAAI,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;wBACxC,GAAG,GAAG,wBAAwB,CAAC,EAAE,IAAI,CAAC,CAAC;qBACxC;iBACF;aACF,CAAC,CAAC;SACJ,CAAC,CAAC;QACH,IAAI,kBAAkB,GAAG,wBAAwB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC9D,IAAI,kBAAkB,CAAC,MAAM,KAAK,eAAe,CAAC,MAAM,EAAE;YACxD,kBAAkB,CAAC,OAAO,CAAC,UAAC,GAAG,EAAE,CAAC,IAAK,QAAC,MAAM,IAAI,GAAG,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAC,CAAC,CAAC;SAC3F;aAAM,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE;;YAExC,OAAO,CAAC,IAAI,CACV,kFAAkF,CACnF,CAAC;SACH;QACD,IAAI,uBAAuB;YAAE,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QACrE,OAAO,MAAM,CAAC;KACf;IAED,+BAAQ,GAAR;QACE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KAC7B;IAEM,2BAAc,GAArB,UAAsB,IAAY,EAAE,WAAgC;QAAhC,4BAAA,EAAA,gCAAgC;QAClE,IAAI,SAAS,GAAG,IAAI;aACjB,IAAI,EAAE;aACN,KAAK,CAAC,yFAAyF,CAAC,CAAC;;;;;;QAMpG,SAAS,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QAC1B,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACnB,IAAI,KAAK,GAAG,EAAE,EACZ,QAAQ,EACR,OAAO,CAAC;QACV,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YAChD,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gBACrB,IAAI,EAAE,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;oBAC3C,SAAS;iBACV;gBACD,OAAO,CAAC,IAAI,CACV,2BAAwB,CAAC,GAAG,CAAC,gCAA0B,IAAI,CAAC,SAAS,CACnE,SAAS,CACV,gBAAa,CACf,CAAC;aACH;YACD,IAAI,SAAS,GAAG,IAAI,SAAS,CAC3B,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,EAChB,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,EAChB,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,EAChB,WAAW,EACX,SAAS,CAAC,CAAC,CAAC,CACb,CAAC;YACF,IAAI,SAAS,CAAC,YAAY,EAAE;gBAC1B,IAAI,OAAO,EAAE;oBACX,SAAS,CAAC,iBAAiB,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;oBAC/D,OAAO,GAAG,IAAI,CAAC;iBAChB;gBACD,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBACtB,QAAQ,GAAG,SAAS,CAAC;aACtB;iBAAM,IAAI,QAAQ,EAAE;gBACnB,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;aAC9D;iBAAM;gBACL,OAAO,GAAG,SAAS,CAAC;aACrB;SACF;QACD,OAAO,KAAK,CAAC;KACd;IACH,mBAAC;AAAD,CAAC,IAAA;AAED;IAOE,mBACE,IAAY,EACZ,GAAW,EACX,IAAY,EACZ,WAAgC,EAChC,WAAoB;QALtB,iBAcC;QAVC,4BAAA,EAAA,gCAAgC;QAGhC,IAAI,WAAW;YAAE,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAChD,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QAC5C,IAAI,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,CAAC,SAAS,GAAG,WAAW,CAAC,GAAG,CAC9B,UAAC,GAAG,EAAE,CAAC,IAAK,OAAA,IAAI,aAAa,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,KAAI,CAAC,GAAA,CAC3F,CAAC;KACH;;;;;IAKD,kCAAc,GAAd,UAAe,WAAmB;QAChC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,IAAI,MAAM,GAAG,WAAW,CAAC;KAC5E;;;;;IAKD,qCAAiB,GAAjB,UAAkB,cAAsB;QACtC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,OAAO,GAAG,cAAc,GAAG,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;KACjF;IAED,4BAAQ,GAAR;QACE,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KACjC;IACH,gBAAC;AAAD,CAAC,IAAA;AAED;IAYE,uBACE,OAAe,EACf,WAAoB,EACpB,UAAmB,EACnB,GAA8B,EAC9B,IAA+B,EAC/B,IAAe;QAEf,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC;QACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC9C,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YAC/B,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;SACxB;QACD,IAAI,CAAC,OAAO,GAAG,CAAC,WAAW,IAAI,GAAG,KAAK,EAAE,CAAC;QAC1C,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,IAAI,IAAI,KAAK,EAAE,CAAC;KAC5C;IAED,gCAAQ,GAAR;QACE,OAAO,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;KAChF;IACD,sCAAc,GAAd;QACE,OAAO,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;KACjE;IACD,uCAAe,GAAf;QACE,OAAO,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;KACjC;IACD,kCAAU,GAAV;QACE,OAAO,IAAI,CAAC,OAAO,CAAC;KACrB;IACD,mCAAW,GAAX;QACE,OAAO,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;KACrD;IAED,gCAAQ,GAAR,UAAS,IAAY;QACnB,OAAO,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,IAAG,MAAI,IAAI,MAAG,CAAA,IAAI,IAAI,CAAC,UAAU,GAAG,IAAI,GAAG,EAAE,CAAC,CAAC;KAC/F;IACH,oBAAC;AAAD,CAAC;;AC/dD;;;;;SAKgB,SAAS,CAAC,IAAY,EAAE,KAAa;IACnD,OAAO,IAAI,CAAC,OAAO,CAAC,yBAAyB,EAAE,UAAC,KAAK,EAAE,IAAI,EAAE,CAAC;QAC5D,IAAI,IAAI;YAAE,OAAO,IAAI,CAAC;QACtB,IAAM,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;QAC1D,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;YAAE,MAAM,6BAA6B,CAAC;QAC9D,OAAO,IAAI,CAAC;KACb,CAAC,CAAC;AACL;;;ICiGE,uBAAY,IAAY,EAAE,MAAW,EAAE,eAAuB,EAAE,IAAW;QAAjD,uBAAA,EAAA,WAAW;QAAE,gCAAA,EAAA,uBAAuB;QAAE,qBAAA,EAAA,WAAW;QACzE,IAAI,KAAK,IAAsB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC,CAAC;QAChD,IAAI,MAAM;YAAE,IAAI,GAAG,MAAM,GAAG,IAAI,CAAC;QACjC,IAAI,KAAK,CAAC;QAEV,IAAI,aAAa,GAAG,+BAA+B,CAAC;QACpD,QAAQ,KAAK,GAAG,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;YACzC,KAAK,CAAC,IAAI,CAAC;gBACT,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG;gBACvB,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG;aACtB,CAAC,CAAC;SACJ;QACD,IAAI,UAAU,GAAqB,EAAE,CAAC;QACtC,IAAI,aAAa,GAAuB,EAAE,CAAC;QAC3C,IAAI,iBAAiB,CAAC;QACtB,IAAI,WAAW,GAAqB,EAAE,CAAC;QACvC,IAAI,eAAe,GAAqB,EAAE,CAAC;QAC3C,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,QAAQ,GAAG,SAAS,CAAC;QACzB,IAAI,SAAS,CAAC;QACd,IAAI,QAAQ,CAAC;QACb,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE;YAC1C,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACnB,IAAI,GAAG,CAAC,MAAM,EAAE;gBACd,iBAAiB,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC1B,aAAa,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;gBACzC,KAAK,GAAG,CAAC,CAAC;gBACV,IAAI,QAAQ,EAAE;oBACZ,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBACjC,QAAQ,GAAG,SAAS,CAAC;iBACtB;qBAAM,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE;oBAC5B,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACxC,EAAE,CAAC,CAAC;iBACL;gBACD,WAAW,GAAG,EAAE,CAAC;aAClB;iBAAM,IAAI,GAAG,CAAC,IAAI,EAAE;gBACnB,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACxB,IAAI,KAAK,IAAI,CAAC,EAAE;;oBAEd,IAAI,aAAa,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE;;;;wBAIjE,WAAW,GAAG,eAAe,CAAC;wBAC9B,eAAe,GAAG,EAAE,CAAC;qBACtB;oBACD,KAAK,GAAG,CAAC,CAAC;iBACX;gBACD,QAAQ,GAAG,GAAG,CAAC;aAChB;iBAAM,IAAI,KAAK,IAAI,CAAC,EAAE;;gBAErB,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;aAC9B;iBAAM,IAAI,KAAK,IAAI,CAAC,EAAE;;gBAErB,IAAI,CAAC,QAAQ,EAAE;;;oBAGb,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;iBAC1B;qBAAM;;;;;oBAKL,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI;wBAAE,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;oBAChF,SAAS;iBACV;gBACD,QAAQ,GAAG,SAAS,CAAC;aACtB;SACF;QACD,IAAI,SAAS,EAAE;YACb,IAAI,eAAe,EAAE;gBACnB,QAAQ,GAAG,SAAS,CAAC;aACtB;iBAAM;;;gBAGL,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;gBACnC,KAAK,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;gBACvC,IAAI,UAAU,GAAG,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,KAAK,IAAI,CAAC,CAAC;gBACjE,IAAI,IAAI,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBACnC,IAAI,IAAI,UAAU,IAAI,CAAC,IAAI,UAAU,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACnD,QAAQ,GAAG,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;aACtC;SACF;QACD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,IAAI,GAAG;YACV,KAAK,EAAE,SAAS;YAChB,IAAI,EAAE,QAAQ;YACd,UAAU,YAAA;YACV,WAAW,aAAA;YACX,eAAe,iBAAA;YACf,OAAO,EAAE,aAAa;SACvB,CAAC;QACF,IAAI,CAAC,cAAc,GAAG;YACpB,UAAU,EAAE,UAAU,CAAC,MAAM;YAC7B,OAAO,EAAE,aAAa,CAAC,MAAM;YAC7B,WAAW,EAAE,WAAW,CAAC,MAAM;YAC/B,eAAe,EAAE,eAAe,CAAC,MAAM;SACxC,CAAC;KACH;;;;;;;;;;;IAnKM,yBAAW,GAAlB,UACE,IAAY,EACZ,OAAkC,EAClC,IAAa;;QADb,wBAAA,EAAA,YAAkC;QAGlC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;QACpC,IAAI,YAAY,GAAG,IAAI,CAAC;QACxB,IAAI,SAAS,GAAG,0BAA0B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtD,IAAI,SAAS,EAAE;gBACP,YAAY,GAAG,SAAS,CAAC,CAAC,CAAC,CACZ;YACrB,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;gBAC3D,IAAM,oBAAoB,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAC3D,mBAAmB,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAC9C,KAAK,GAAG,CAAC,IAAI,mBAAmB,GAAG,oBAAoB,CAAC,CAAC;;gBAE3D,IAAI;oBACF,IAAI,GAAG,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;iBAC/B;gBAAC,OAAM,SAAS,EAAE;oBACjB,IAAI,GAAG,YAAY,CAAC;iBACrB;aACF;iBAAM;gBACL,IAAI,GAAG,YAAY,CAAC;aACrB;YACD,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;SAC1D;aAAM,IAAI,CAAC,IAAI,EAAE;YAChB,IAAI,GAAG,IAAI,CAAC;SACb;QACD,YAAY,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QACxC,IAAI,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACrC,IAAI,YAAY,CAAC,MAAM,IAAI,CAAC,EAAE;YAC5B,OAAO,CAAC,IAAI,CAAC,mDAAmD,EAAE,IAAI,CAAC,CAAC;SACzE;QACD,IAAI,cAAc,GAAG,YAAY,CAAC,GAAG,CAAC,UAAA,IAAI;YACxC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;YACzC,IAAI,OAAO,CAAC,gCAAgC,EAAE;gBAC5C,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC;gBAC7C,IAAI,KAAK,EAAE;;oBAET,IAAI;wBACF,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;4BAC/B,IAAI;4BACJ,KAAK,CAAC,CAAC,CAAC;4BACR,GAAG;4BACH,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE;4BACtB,IAAI;4BACJ,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;iBAC1B;aACF;YACD,OAAO,IAAI,aAAa,CAAC,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;SAChD,CAAC,CAAC;QACH;YACE,GAACA,wBAAgB,CAAC,OAAO,IAAG,cAAc,CAAC,CAAC,CAAC;YAC7C,GAACA,wBAAgB,CAAC,WAAW,IAAG,cAAc,CAAC,CAAC,CAAC;YACjD,eAAY,eAAA;YACZ,OAAI,OAAA;eACJ;KACH;IA2GH,oBAAC;AAAD,CAAC;;;;;;;"}